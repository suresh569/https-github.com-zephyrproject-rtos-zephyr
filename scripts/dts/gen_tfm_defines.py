#!/usr/bin/env python3
# Copyright (c) 2024 Embeint Inc
# SPDX-License-Identifier: Apache-2.0

import argparse
import sys
import os
import pickle

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "python-devicetree", "src"))

class TFMDefine:
    """Trusted-Firmware-M build system define"""
    def __init__(self, name, value, size=False):
        self.name = name
        self.value = value
        self.size = size

    def __str__(self):
        if isinstance(self.value, int):
            val = f"0x{self.value:08x}"
            if self.size:
                val += f" /* {self.value // 1024}kB */"
        else:
            val = self.value
        return f"#define {self.name:<40s} {val}"


def parse_args():
    """ Returns parsed command-line arguments """
    parser = argparse.ArgumentParser(allow_abbrev=False)
    parser.add_argument(
        "--edt-pickle",
        required=True,
        help="path to read the pickled edtlib.EDT object from",
    )
    parser.add_argument("--header-out", required=True, help="path to write header to")

    return parser.parse_args()


def file_header(args):
    """Generated header file header"""
    return f"""/*
 * Generated by gen_tfm_defines.py
 *
 * DTS pickle file:
 *   {args.edt_pickle}
 */
"""

def common_defines(tfm):
    """Common SoC defines that don't depend on flash regions"""
    sram = tfm["sram"].val
    sram_s = tfm["sram-secure"].val
    sram_ns = tfm["sram-nonsecure"].val

    return {
        sram.path: [
            TFMDefine("SRAM_BASE_ADDRESS", sram.regs[0].addr),
            TFMDefine("TOTAL_RAM_SIZE", sram.regs[0].size, True),
        ],
        sram_s.path: [
            TFMDefine("S_DATA_START", sram_s.regs[0].addr),
            TFMDefine("S_DATA_SIZE", sram_s.regs[0].size, True),
            TFMDefine("S_DATA_LIMIT", sram_s.regs[0].addr + sram_s.regs[0].size - 1),
        ],
        sram_ns.path: [
            TFMDefine("NS_DATA_START", sram_ns.regs[0].addr),
            TFMDefine("NS_DATA_SIZE", sram_ns.regs[0].size, True),
            TFMDefine("NS_DATA_LIMIT", sram_ns.regs[0].addr + sram_ns.regs[0].size - 1),
        ],
        "System Protection Unit": [
            TFMDefine("SPU_FLASH_REGION_SIZE", tfm["spu-flash-region-size"].val, True),
            TFMDefine("SPU_SRAM_REGION_SIZE", tfm["spu-sram-region-size"].val, True),
        ],
    }


def flash_device_defines(index, device):
    """Flash device specific defines"""
    prefix = device.props["define-prefix"].val
    complete = device.props["complete"].val

    # Defer to size property (in bits) if it exists
    if "size" in complete.props:
        complete_size = complete.props["size"].val // 8
    else:
        complete_size = complete.regs[0].size
    # Optional override of the sector size
    if "erase-block-size" in device.props:
        erase_size = device.props["erase-block-size"].val
    else:
        erase_size = complete.props["erase-block-size"].val
    if "write-block-size" in device.props:
        write_size = device.props["write-block-size"].val
    else:
        write_size = complete.props["write-block-size"].val

    defines = {
        complete.path: [
            TFMDefine(f"{prefix}FLASH_DRIVER", device.props["driver"].val),
            TFMDefine(f"{prefix}FLASH_DRIVER_ID", f"(FLASH_DEVICE_ID + {index})"),
            TFMDefine(f"{prefix}FLASH_BASE_ADDRESS", complete.regs[0].addr),
            TFMDefine(f"{prefix}FLASH_TOTAL_SIZE", complete_size, True),
            TFMDefine(f"{prefix}FLASH_AREA_IMAGE_SECTOR_SIZE", erase_size, True),
            TFMDefine(f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE", write_size),
        ],
    }
    if "extra-defines" in device.props:
        for extra in device.props["extra-defines"].val:
            defines[complete.path].append(TFMDefine(*extra.split("=")))

    if "img-bl2" in device.props:
        flash_bl2 = device.props["img-bl2"].val
        defines[flash_bl2.path] = [
            TFMDefine("FLASH_AREA_BL2_OFFSET", flash_bl2.regs[0].addr),
            TFMDefine("FLASH_AREA_BL2_SIZE", flash_bl2.regs[0].size, True),
            TFMDefine("FLASH_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_FLASH_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
        ]

    if "img-primary-secure" in device.props:
        flash_s = device.props["img-primary-secure"].val
        defines[flash_s.path] = [
            TFMDefine("FLASH_S_PARTITION_OFFSET", flash_s.regs[0].addr),
            TFMDefine("FLASH_S_PARTITION_SIZE", flash_s.regs[0].size, True),
            TFMDefine("FLASH_DEV_NAME_0", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_0", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-primary-nonsecure" in device.props:
        flash_ns = device.props["img-primary-nonsecure"].val
        defines[flash_ns.path] = [
            TFMDefine("FLASH_NS_PARTITION_OFFSET", flash_ns.regs[0].addr),
            TFMDefine("FLASH_NS_PARTITION_SIZE", flash_ns.regs[0].size, True),
            TFMDefine("FLASH_NS_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_1", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_1", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-secondary-secure" in device.props:
        flash_s = device.props["img-secondary-secure"].val
        defines[flash_s.path] = [
            TFMDefine("FLASH_S1_S_PARTITION_OFFSET", flash_s.regs[0].addr),
            TFMDefine("FLASH_S1_S_PARTITION_SIZE", flash_s.regs[0].size, True),
            TFMDefine("FLASH_S1_S_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_2", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_2", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-secondary-nonsecure" in device.props:
        flash_ns = device.props["img-secondary-nonsecure"].val
        defines[flash_ns.path] = [
            TFMDefine("FLASH_S1_NS_PARTITION_OFFSET", flash_ns.regs[0].addr),
            TFMDefine("FLASH_S1_NS_PARTITION_SIZE", flash_ns.regs[0].size, True),
            TFMDefine("FLASH_S1_NS_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_3", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_3", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "partition-ps" in device.props:
        flash_ps = device.props["partition-ps"].val
        defines[flash_ps.path] = [
            TFMDefine("TFM_HAL_PS_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_PS_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
            TFMDefine("TFM_HAL_PS_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_PS_AREA_OFFSET", flash_ps.regs[0].addr),
            TFMDefine("FLASH_PS_AREA_SIZE", flash_ps.regs[0].size, True),
        ]

    if "partition-its" in device.props:
        flash_its = device.props["partition-its"].val
        defines[flash_its.path] = [
            TFMDefine("TFM_HAL_ITS_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_ITS_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
            TFMDefine("TFM_HAL_ITS_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_ITS_AREA_OFFSET", flash_its.regs[0].addr),
            TFMDefine("FLASH_ITS_AREA_SIZE", flash_its.regs[0].size, True),
        ]

    if "partition-otp" in device.props:
        flash_otp = device.props["partition-otp"].val
        defines[flash_otp.path] = [
            TFMDefine("TFM_HAL_OTP_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine("TFM_HAL_OTP_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_OTP_NV_COUNTERS_AREA_OFFSET", flash_otp.regs[0].addr),
            TFMDefine("FLASH_OTP_NV_COUNTERS_AREA_SIZE", flash_otp.regs[0].size, True),
            TFMDefine(
                "FLASH_OTP_NV_COUNTERS_SECTOR_SIZE",
                f"{prefix}FLASH_AREA_IMAGE_SECTOR_SIZE",
            ),
        ]

    if "partition-nonsecure-storage" in device.props:
        flash_ns_storage = device.props["partition-nonsecure-storage"].val
        defines[flash_ns_storage.path] = [
            TFMDefine(
                "NRF_FLASH_NS_STORAGE_AREA_OFFSET", flash_ns_storage.regs[0].addr
            ),
            TFMDefine(
                "NRF_FLASH_NS_STORAGE_AREA_SIZE", flash_ns_storage.regs[0].size, True
            ),
        ]
    return defines


def define_gen(define_dict):
    """Convert dictionary of nodes and defines to C header text"""
    content = ""
    for node, defines in define_dict.items():
        content += "\n"
        content += f"/* {node} */\n"
        content += "\n".join([str(d) for d in defines])
        content += "\n"
    return content


def main():
    args = parse_args()

    with open(args.edt_pickle, "rb") as f:
        edt = pickle.load(f)

    tfm_compat = "arm,trusted-firmware-m"
    tfm = edt.compat2nodes[tfm_compat]

    content = file_header(args)
    if len(tfm) == 1:
        content += define_gen(common_defines(tfm[0].props))
        for idx, flash_dev in enumerate(tfm[0].children.values()):
            content += define_gen(flash_device_defines(idx, flash_dev))
    else:
        # Silent failure for boards that don't support devicetree defines
        content += f"""\nExpected exactly one node with compat `{tfm_compat}`\n"""

    with open(args.header_out, "w", encoding="utf-8") as f:
        f.write(content)


if __name__ == "__main__":
    main()
